#4 Goでの並行処理パターン

##4.1 拘束
- イミュータブル: そもそも変更不可能なオブジェクトを使用する(要素の数などを変更不可能な配列など)
- レキシカルな拘束: チャネルで入出力を引数と戻り値を使って制御することで競合をそもそも起こさない。スコープで制約する。
- Fprintf: 先頭のFは書き込み先を明示的に指定する。
- byte型, bytes.Buffer: asciiコードの文字列

##4.2 for-selectループ
- for文で無限ループしてselectでチャンネルをさばいていく

##4.3 ゴルーチンリークを避ける
- p93のコードはstringsをまってdoWorkをブロックし続ける
- p93-2のコードはdoWorkはselectで何も読めるチャネルがないためブロックされる。4はdoWorkが終了するまでブロックされる。ゴルーチンでdoneチャネルがcloseされdoWorkのブロックが解除される。
- p94のnewRandStreamはfor文が閉じずにnewRandStreamが終了する
- p95はdoneがcloseするのでfor文がちゃんと閉じて、ゴルーチンが終了する。

##4.4 orチャネル
- doneチャネルを作成する際にゴルーチンの終了条件となるdoneチャネルが複数あり、その一つでもcloseした際にすべてのチャネルを終了するロジックを組む。
- 流れとしては再帰的にorが呼ばれていき、どれか一つのチャネルがcloseすればorDoneが呼ばれて上位に渡されていき、最終的に終了する。

##4.5 エラーハンドリング
- ゴルーチンに異常系がある場合、エラーはちゃんと渡せということ
- これ以上の情報はない

##4.6 パイプライン
- 入力を変形して出力するコンポーネントを作成して、コンポーネント内とコンポーネントの接続の問題を切り分けることができる。このデータの流れをパイプラインと呼ぶ。
- パイプラインのステージの性質として、入力と出力の型が同一である。
- パイプラインにはバッチ指向のものとストリーム指向のものがある。
###4.6.1
- 　　　　　　　　　　　　　　　　　　　　　