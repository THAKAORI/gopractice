#4 Goでの並行処理パターン

##4.1 拘束
- イミュータブル: そもそも変更不可能なオブジェクトを使用する(要素の数などを変更不可能な配列など)
- レキシカルな拘束: チャネルで入出力を引数と戻り値を使って制御することで競合をそもそも起こさない。スコープで制約する。
- Fprintf: 先頭のFは書き込み先を明示的に指定する。
- byte型, bytes.Buffer: asciiコードの文字列

##4.2 for-selectループ
- for文で無限ループしてselectでチャンネルをさばいていく

##4.3 ゴルーチンリークを避ける
- p93のコードはstringsをまってdoWorkをブロックし続ける
- p93-2のコードはdoWorkはselectで何も読めるチャネルがないためブロックされる。4はdoWorkが終了するまでブロックされる。ゴルーチンでdoneチャネルがcloseされdoWorkのブロックが解除される。
- p94のnewRandStreamはfor文が閉じずにnewRandStreamが終了する
- p95はdoneがcloseするのでfor文がちゃんと閉じて、ゴルーチンが終了する。

##4.4 orチャネル
- doneチャネルを作成する際にゴルーチンの終了条件となるdoneチャネルが複数あり、その一つでもcloseした際にすべてのチャネルを終了するロジックを組む。
- 流れとしては再帰的にorが呼ばれていき、どれか一つのチャネルがcloseすればorDoneが呼ばれて上位に渡されていき、最終的に終了する。

##4.5 エラーハンドリング
- ゴルーチンに異常系がある場合、エラーはちゃんと渡せということ
- これ以上の情報はない

##4.6 パイプライン
- 入力を変形して出力するコンポーネントを作成して、コンポーネント内とコンポーネントの接続の問題を切り分けることができる。このデータの流れをパイプラインと呼ぶ。
- パイプラインのステージの性質として、入力と出力の型が同一である。
- パイプラインにはバッチ指向のものとストリーム指向のものがある。
###4.6.1
- この章ではgeneratorというものが特筆されている。パイプラインで処理すべきチャネルを生成することができる。可変個の入力をチャネルで並行で処理することができる。バッチ処理とストリーム処理の両方の利点を備えていると言える。p109の表でわかる。
###4.6.2
- 無限ループでgenarateし続けて、必要な数だけ取ってチャンネルを閉じる。
- p112の２つの矢印はアドレスを取り出して、その値を取っているぽい？
- 関数のタイプや型アサーションをつけるタイプ
- p115のテストの解説として、2倍弱速度差が発生しているが現実にはI/Oの時間がボトルネックになるので十分無視できる。(オーダーが同じ)またどこかの段階のステージが重いとさらにどうでも良くなる。

##4.7 ファンアウト、ファンイン
- 重いステージが存在する場合に、上流のステージから値を取って並列に処理したい。
- ファンアウトが重い処理を並列化する部分であり、ファンインが並列化された処理の結果を一つのチャンネルにまとめる処理である。
- ファンアウトで並列化された処理はsync WaitGroupで処理される。

##4.8 or-doneチャネル
- チャネルをrangeを使って読み込む際に終了条件doneを考慮したい際に、外部のfor文で終了処理を指せるのではなくfuncにやらせる。

##4.9 teeチャネル
- 一つの入力から2つのストリームを作成する。
- p123のコードの3はp76にあるようにブロックする。

##4.10 bridgeチャネル
- チャネルのシーケンスを崩して一つのチャネルにする技を見せている。
- 何が役に立つかはよくわからない

##4.11 キュー
- 前半ではチャネルのキューの有用性が高速化ではなく、ステージを分離することにより下流のステージによって上流のステージがブロックされることを防ぐことだということが述べられている。
- キューが有用性を発揮する際として二つのパターンがある。
    - 入力がバッチ的に処理されるとき。メモリからちょっとずつディスクに書き込むのではなくまとめて書き込むときなど。まとめることをチャンキングと呼ぶ。これは主にオーバヘッドが大きい処理で有用。
    - パイプラインに入力を流す機構がパイプラインの効率に依存しているときに悪いフィードバックがかかるとき。(コロナでトイレットぺーバーが売り切れたから、みんな買い占め始めるとか？整理券を配り始めるということ)。その時キューはパイプラインの入り口(整理券)かバッチ処理によって効率的になるステージの前(レジにまとめて商品を持っていく)におく。(レジが終わったあとに人をまとめて帰らせても良いことはない)
- リトルの法則から最適なキューの数を算出することができる。p133の例はリクエストの数が間違っている気がする。
- キューは最適化の最終手段

##4.12 contextパッケージ
- doneチャネルよりもより多くの情報を内包するcontextパッケージ
- コールグラフはコンピュータ・プログラムの呼び出しのグラフ構造のこと
- doneの発展バージョン
- p136ではBackgroundは基本のcontextの型。
- p139のコードはcontextに性質を付け足していっても上流に影響しない。